<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个要奋进的程序媛"><meta name="keywords" content="python"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>test | 你好啊，慧</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">test</h1><a id="logo" href="/.">你好啊，慧</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">test</h1><div class="post-meta"><a href="/2019/11/21/test/#comments" class="comment-count"></a><p><span class="date">Nov 21, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h3 id="图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G-V-E），V是顶点集，E-为边集。"><a href="#图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G-V-E），V是顶点集，E-为边集。" class="headerlink" title="图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G(V,E），V是顶点集，E 为边集。"></a>图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G(V,E），V是顶点集，E 为边集。</h3><p>一般图分为有向图和无向图。<br>顶点的度是指和该顶点相连的边的条数。特变的对于有向图，顶点的出边条数成为出度，顶点的蠕变条数成为入度。顶点和边都可以由一些属性，称为点权和边权。</p>
<h3 id="图的存储："><a href="#图的存储：" class="headerlink" title="图的存储："></a>图的存储：</h3><p>图可以使用两种存储方式：<strong>邻接矩阵和邻接表</strong>。</p>
<h4 id="邻接矩阵：适合顶点数目不多的稠密图。"><a href="#邻接矩阵：适合顶点数目不多的稠密图。" class="headerlink" title="邻接矩阵：适合顶点数目不多的稠密图。"></a>邻接矩阵：适合顶点数目不多的稠密图。</h4><p>设图G(V,E)的顶点编号为0-N-1，那么可以令二维数组G[N][N]的两维分别表示图的顶点标号，及如果G[i][j]的值为1，表示i和j之间有变。这个二维矩阵被称为邻接矩阵。并且如果存在边权可以让G[N][N]中存放边权。<br>无向图的邻接矩阵是对称矩阵。</p>
<h4 id="邻接表-适合顶点个数较多的稀疏图。"><a href="#邻接表-适合顶点个数较多的稀疏图。" class="headerlink" title="邻接表:适合顶点个数较多的稀疏图。"></a>邻接表:适合顶点个数较多的稀疏图。</h4><p>设图G(V,E)的顶点标号为0，1，… ，N-1，每个顶点都有可能有若干条出边，如果把同一个顶点的所有出边放在一个列表中，那么N个顶点就会有N个列表（没有出边，对应空表）。这N个列表被称为图的邻接表。记作Adj[N]。<br>邻接表实现可以使用变长数组vector，开一个vector数组Adj[N], N是顶点个数，每个顶点对应一个变长数组，存储其出边。<br>如下所示：<br><code>&lt;Vector&lt;int&gt; Adj[N];&gt;</code><br>如果节点还有权值，我们可以定义一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct Node&#123;</span><br><span class="line">     Int v;</span><br><span class="line">     Int w;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后vector邻接表中的元素类型就是Node型的。<br><code>&lt;Vector&lt;Node&gt; Adj[N];&gt;</code></p>
<h3 id="图的遍历："><a href="#图的遍历：" class="headerlink" title="图的遍历："></a>图的遍历：</h3><p>是指对图的所有顶点按一定顺序进行访问，遍历方法一般有两种：深度优先搜索（DFS）和广度优先搜索（BFS）。</p>
<h4 id="深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。"><a href="#深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。" class="headerlink" title="深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。"></a>深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。</h4><p>DFS的具体实现，首先介绍两个概念：<br>连通分量。在无向图中，如果两个顶点之间可以相互到达（可以是通过一定路径间接到达），那么就称这两个顶点连通。如果图G(V,E)的任意两个顶点都连通，则通图G为连通图，否则称G为非连通图，且称其中的极大连通子图为连通分量。<br>强连通分量。在有向图中，如果俩ing个顶点可以各自通过一条有向路径到达另一个顶点，就称这两个顶点强连通。如果图G(V,E)的任意两个顶点都强连通，则称图G为强连通图；否则称G为非强连通图，且称其中的极大强连通子图为强连通分量。<br>如果要遍历一个图就要对所有的连通块进行遍历，如果已知的图是连通图，则只需要一次DFS遍历就可以完成。<br>DFS的伪代码：（可以使用临界矩阵和邻接表实现）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DFS(u)&#123;//访问顶点u</span><br><span class="line">    vis[u] = true; //设置u为已访问</span><br><span class="line">    for(从u出发能到达的所有顶点v)&#123;  //枚举从u出发可以到达的所有顶点v</span><br><span class="line">        if(vis[v] == false)&#123;</span><br><span class="line">        DFS(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123; //遍历图</span><br><span class="line">    for(G 的所有顶点u) //对G的所有顶点u</span><br><span class="line">        if vis[u] == false //如果u未被访问</span><br><span class="line">            DFS(u); //访问u所在的连通块</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="广度优先搜索（BFS）遍历图"><a href="#广度优先搜索（BFS）遍历图" class="headerlink" title="广度优先搜索（BFS）遍历图"></a>广度优先搜索（BFS）遍历图</h4><p>广度优先搜索以“广度”作为关键词，每次以扩散的方式向外访问顶点。和树的遍历一样，使用BFS遍历图需要使用一个队列，通过反复取出队首顶点，将该顶点可到达的未曾加入过队列的顶点全部入队，（而不是未被访问）直到队列为空时遍历结束。<br>可以查看下面的伪代码，根据思路可以使用邻接表和临界矩阵进行实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BFS(u)&#123; //遍历u所在的连通块</span><br><span class="line">    queue q;//定义队列q</span><br><span class="line">    将u入队；</span><br><span class="line">    inq[u] = true;</span><br><span class="line">    while(q 非空)&#123;</span><br><span class="line">        取出队首元素u进行访问；</span><br><span class="line">        for(从u出发可达到的所有顶点v)</span><br><span class="line">            if( inq[v] == false) &#123; //如果v未曾加入过队列</span><br><span class="line">                将v入队；</span><br><span class="line">                inq[v] = true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123;</span><br><span class="line">    for(G 的所有顶点u)</span><br><span class="line">        if(inq[u] == false)&#123; //如果u未曾加入过队列</span><br><span class="line">            BFS(u); //遍历u所在的连通块</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="最短路径问题："><a href="#最短路径问题：" class="headerlink" title="最短路径问题："></a>最短路径问题：</h3><h3 id="最小生成树（Minimum-Spanning-Tree-MST）："><a href="#最小生成树（Minimum-Spanning-Tree-MST）：" class="headerlink" title="最小生成树（Minimum Spanning Tree,MST）："></a>最小生成树（Minimum Spanning Tree,MST）：</h3><p>是在一个给定的无向图G(V,E)中求一棵树T,使这棵树拥有图G中的所有顶点，且所有边都来自图G中，并且满足整棵树的边权之和最小。<br>最小生成树有三个性质需要掌握：<br>    1. 最小生成树是树，因此其边数等于顶点数减一，且树内一定不会有环。<br>    2. 对给定的图G(V,E)，其最小生成树可以不唯一，但其边权之和一定是唯一的。<br>    3. 由于最小生成树是在无向图上生成的，因此其根节点可以是这棵树上的任意一个结点。一般为了输出唯一，会指定一个结点作为根节点。<br>常用的算法有：Prim（普利姆算法）和 Kruskal算法（克鲁斯卡尔算法）</p>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>伪代码如下，其时间复杂度为O(V^2)，如果图用邻接表实现，可以使用堆优化即使用优先级队列将复杂度降低为O(VlogV + E)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">G为图，S是以及加入图中的顶点集，数组d为顶点与集合S的最短距离</span><br><span class="line">Prim(G,d[])&#123;</span><br><span class="line">    初始化G[],d[],d[1] = 0;</span><br><span class="line">    for(循环n次)</span><br><span class="line">    &#123;</span><br><span class="line">        u = 使d[u]最小的还未被访问的顶点的标号；</span><br><span class="line">        记录u已被访问；</span><br><span class="line">        for(从 u 出发能到达的所有顶点v)&#123;</span><br><span class="line">            if(v 未被访问 &amp;&amp; 以u为中介点使得v与集合S的最短距离d[v]更优)&#123;</span><br><span class="line">                将G[u][v]赋值给d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>伪代码如下，其时间负责度主要在拍于函数上，是O(ElogE)，其中E是图的边数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int kruskal()&#123;</span><br><span class="line">    令最小生成树的边权之和为ans,最小生成树的当前边数Num_edge;</span><br><span class="line">    将所有边按照边权从小到达排序;</span><br><span class="line">    for(从小到大枚举所有边)</span><br><span class="line">    &#123;</span><br><span class="line">        if(当前测试边的两个端点在不同的连通块中)&#123; //判断是否在一个联通块中可以使用并查集</span><br><span class="line">            将该测试边加入最小生成树;</span><br><span class="line">            ans += 测试边的边权;</span><br><span class="line">            最小生成树的当前边数num_edge+1;</span><br><span class="line">            当前边数num_edge 等于定点数减一时结束循环;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的时间复杂度分析可知，Prim 算法的时间复杂度与V相关，适合稠密图（顶点少边多），而kruskal算法的实际复杂度与E的数目有关，适合稀疏图（顶点多，边少）。</p>
<h3 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h3><h3 id="关键路径："><a href="#关键路径：" class="headerlink" title="关键路径："></a>关键路径：</h3><p>参考内容：《算法笔记》 胡凡 曾磊主编</p>
</div><div class="post-copyright"><blockquote><p>Original author: John Doe</p><p>Original link: <a href="http://yoursite.com/2019/11/21/test/">http://yoursite.com/2019/11/21/test/</a></p><p>Copyright Notice: Please indicate the source of the reprint (must retain the author's signature and link)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2019/10/27/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" class="next">Markdown使用教程</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G-V-E），V是顶点集，E-为边集。"><span class="toc-text">图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G(V,E），V是顶点集，E 为边集。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的存储："><span class="toc-text">图的存储：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#邻接矩阵：适合顶点数目不多的稠密图。"><span class="toc-text">邻接矩阵：适合顶点数目不多的稠密图。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#邻接表-适合顶点个数较多的稀疏图。"><span class="toc-text">邻接表:适合顶点个数较多的稀疏图。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的遍历："><span class="toc-text">图的遍历：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。"><span class="toc-text">深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#广度优先搜索（BFS）遍历图"><span class="toc-text">广度优先搜索（BFS）遍历图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路径问题："><span class="toc-text">最短路径问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小生成树（Minimum-Spanning-Tree-MST）："><span class="toc-text">最小生成树（Minimum Spanning Tree,MST）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim算法"><span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal算法"><span class="toc-text">Kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序："><span class="toc-text">拓扑排序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键路径："><span class="toc-text">关键路径：</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/test/">test</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">Markdown使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/24/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">John Doe.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>