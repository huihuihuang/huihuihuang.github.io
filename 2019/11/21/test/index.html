<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个要奋进的程序媛"><title>test | 哈哈哈，你好！</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">test</h1><a id="logo" href="/.">哈哈哈，你好！</a><p class="description">hhh</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">test</h1><div class="post-meta">Nov 21, 2019</div><div class="post-content"><h3 id="图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G-V-E），V是顶点集，E-为边集。"><a href="#图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G-V-E），V是顶点集，E-为边集。" class="headerlink" title="图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G(V,E），V是顶点集，E 为边集。"></a>图的定义：图由顶点和边组成，每条边的两端是图的两个顶点。记作G(V,E），V是顶点集，E 为边集。</h3><p>一般图分为有向图和无向图。<br>顶点的度是指和该顶点相连的边的条数。特变的对于有向图，顶点的出边条数成为出度，顶点的蠕变条数成为入度。顶点和边都可以由一些属性，称为点权和边权。</p>
<h3 id="图的存储："><a href="#图的存储：" class="headerlink" title="图的存储："></a>图的存储：</h3><p>图可以使用两种存储方式：<strong>邻接矩阵和邻接表</strong>。</p>
<h4 id="邻接矩阵：适合顶点数目不多的稠密图。"><a href="#邻接矩阵：适合顶点数目不多的稠密图。" class="headerlink" title="邻接矩阵：适合顶点数目不多的稠密图。"></a>邻接矩阵：适合顶点数目不多的稠密图。</h4><p>设图G(V,E)的顶点编号为0-N-1，那么可以令二维数组G[N][N]的两维分别表示图的顶点标号，及如果G[i][j]的值为1，表示i和j之间有变。这个二维矩阵被称为邻接矩阵。并且如果存在边权可以让G[N][N]中存放边权。<br>无向图的邻接矩阵是对称矩阵。</p>
<h4 id="邻接表-适合顶点个数较多的稀疏图。"><a href="#邻接表-适合顶点个数较多的稀疏图。" class="headerlink" title="邻接表:适合顶点个数较多的稀疏图。"></a>邻接表:适合顶点个数较多的稀疏图。</h4><p>设图G(V,E)的顶点标号为0，1，… ，N-1，每个顶点都有可能有若干条出边，如果把同一个顶点的所有出边放在一个列表中，那么N个顶点就会有N个列表（没有出边，对应空表）。这N个列表被称为图的邻接表。记作Adj[N]。<br>邻接表实现可以使用变长数组vector，开一个vector数组Adj[N], N是顶点个数，每个顶点对应一个变长数组，存储其出边。<br>如下所示：<br><code>&lt;Vector&lt;int&gt; Adj[N];&gt;</code><br>如果节点还有权值，我们可以定义一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct Node&#123;</span><br><span class="line">     Int v;</span><br><span class="line">     Int w;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后vector邻接表中的元素类型就是Node型的。<br><code>&lt;Vector&lt;Node&gt; Adj[N];&gt;</code></p>
<h3 id="图的遍历："><a href="#图的遍历：" class="headerlink" title="图的遍历："></a>图的遍历：</h3><p>是指对图的所有顶点按一定顺序进行访问，遍历方法一般有两种：深度优先搜索（DFS）和广度优先搜索（BFS）。</p>
<h4 id="深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。"><a href="#深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。" class="headerlink" title="深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。"></a>深度优先搜索以“深度”作为第一关键词，每次都沿着路径到不能再前进时才退回到最近的岔路口。</h4><p>DFS的具体实现，首先介绍两个概念：<br>连通分量。在无向图中，如果两个顶点之间可以相互到达（可以是通过一定路径间接到达），那么就称这两个顶点连通。如果图G(V,E)的任意两个顶点都连通，则通图G为连通图，否则称G为非连通图，且称其中的极大连通子图为连通分量。<br>强连通分量。在有向图中，如果俩ing个顶点可以各自通过一条有向路径到达另一个顶点，就称这两个顶点强连通。如果图G(V,E)的任意两个顶点都强连通，则称图G为强连通图；否则称G为非强连通图，且称其中的极大强连通子图为强连通分量。<br>如果要遍历一个图就要对所有的连通块进行遍历，如果已知的图是连通图，则只需要一次DFS遍历就可以完成。<br>DFS的伪代码：（可以使用临界矩阵和邻接表实现）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DFS(u)&#123;//访问顶点u</span><br><span class="line">    vis[u] = true; //设置u为已访问</span><br><span class="line">    for(从u出发能到达的所有顶点v)&#123;  //枚举从u出发可以到达的所有顶点v</span><br><span class="line">        if(vis[v] == false)&#123;</span><br><span class="line">        DFS(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123; //遍历图</span><br><span class="line">    for(G 的所有顶点u) //对G的所有顶点u</span><br><span class="line">        if vis[u] == false //如果u未被访问</span><br><span class="line">            DFS(u); //访问u所在的连通块</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="广度优先搜索（BFS）遍历图"><a href="#广度优先搜索（BFS）遍历图" class="headerlink" title="广度优先搜索（BFS）遍历图"></a>广度优先搜索（BFS）遍历图</h4><p>广度优先搜索以“广度”作为关键词，每次以扩散的方式向外访问顶点。和树的遍历一样，使用BFS遍历图需要使用一个队列，通过反复取出队首顶点，将该顶点可到达的未曾加入过队列的顶点全部入队，（而不是未被访问）直到队列为空时遍历结束。<br>可以查看下面的伪代码，根据思路可以使用邻接表和临界矩阵进行实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BFS(u)&#123; //遍历u所在的连通块</span><br><span class="line">    queue q;//定义队列q</span><br><span class="line">    将u入队；</span><br><span class="line">    inq[u] = true;</span><br><span class="line">    while(q 非空)&#123;</span><br><span class="line">        取出队首元素u进行访问；</span><br><span class="line">        for(从u出发可达到的所有顶点v)</span><br><span class="line">            if( inq[v] == false) &#123; //如果v未曾加入过队列</span><br><span class="line">                将v入队；</span><br><span class="line">                inq[v] = true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123;</span><br><span class="line">    for(G 的所有顶点u)</span><br><span class="line">        if(inq[u] == false)&#123; //如果u未曾加入过队列</span><br><span class="line">            BFS(u); //遍历u所在的连通块</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="最短路径问题："><a href="#最短路径问题：" class="headerlink" title="最短路径问题："></a>最短路径问题：</h3><h3 id="最小生成树（Minimum-Spanning-Tree-MST）："><a href="#最小生成树（Minimum-Spanning-Tree-MST）：" class="headerlink" title="最小生成树（Minimum Spanning Tree,MST）："></a>最小生成树（Minimum Spanning Tree,MST）：</h3><p>是在一个给定的无向图G(V,E)中求一棵树T,使这棵树拥有图G中的所有顶点，且所有边都来自图G中，并且满足整棵树的边权之和最小。<br>最小生成树有三个性质需要掌握：<br>    1. 最小生成树是树，因此其边数等于顶点数减一，且树内一定不会有环。<br>    2. 对给定的图G(V,E)，其最小生成树可以不唯一，但其边权之和一定是唯一的。<br>    3. 由于最小生成树是在无向图上生成的，因此其根节点可以是这棵树上的任意一个结点。一般为了输出唯一，会指定一个结点作为根节点。<br>常用的算法有：Prim（普利姆算法）和 Kruskal算法（克鲁斯卡尔算法）</p>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>伪代码如下，其时间复杂度为O(V^2)，如果图用邻接表实现，可以使用堆优化即使用优先级队列将复杂度降低为O(VlogV + E)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">G为图，S是以及加入图中的顶点集，数组d为顶点与集合S的最短距离</span><br><span class="line">Prim(G,d[])&#123;</span><br><span class="line">    初始化G[],d[],d[1] = 0;</span><br><span class="line">    for(循环n次)</span><br><span class="line">    &#123;</span><br><span class="line">        u = 使d[u]最小的还未被访问的顶点的标号；</span><br><span class="line">        记录u已被访问；</span><br><span class="line">        for(从 u 出发能到达的所有顶点v)&#123;</span><br><span class="line">            if(v 未被访问 &amp;&amp; 以u为中介点使得v与集合S的最短距离d[v]更优)&#123;</span><br><span class="line">                将G[u][v]赋值给d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>伪代码如下，其时间负责度主要在拍于函数上，是O(ElogE)，其中E是图的边数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int kruskal()&#123;</span><br><span class="line">    令最小生成树的边权之和为ans,最小生成树的当前边数Num_edge;</span><br><span class="line">    将所有边按照边权从小到达排序;</span><br><span class="line">    for(从小到大枚举所有边)</span><br><span class="line">    &#123;</span><br><span class="line">        if(当前测试边的两个端点在不同的连通块中)&#123; //判断是否在一个联通块中可以使用并查集</span><br><span class="line">            将该测试边加入最小生成树;</span><br><span class="line">            ans += 测试边的边权;</span><br><span class="line">            最小生成树的当前边数num_edge+1;</span><br><span class="line">            当前边数num_edge 等于定点数减一时结束循环;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的时间复杂度分析可知，Prim 算法的时间复杂度与V相关，适合稠密图（顶点少边多），而kruskal算法的实际复杂度与E的数目有关，适合稀疏图（顶点多，边少）。</p>
<h3 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h3><h3 id="关键路径："><a href="#关键路径：" class="headerlink" title="关键路径："></a>关键路径：</h3><p>参考内容：《算法笔记》 胡凡 曾磊主编</p>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2019/10/27/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">Markdown使用教程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/test/">test</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">Markdown使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/24/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">哈哈哈，你好！.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>